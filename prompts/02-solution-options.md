# Варианты решения (Solution Space)

Итоговое зафиксированное пространство решений для задачи backend диалогового AI-сайта (CIP): приём сообщений, вызов LLM, выдача ответа пользователю, хранение диалогов.

**Контекст SaaS (из постановки):** Система должна быть реализована как многопользовательская SaaS-платформа. Все варианты ниже предполагают мультитенантность: изоляция данных по tenant_id (владелец инстанса/сайта), масштабируемость на множество тенантов, единый код и инфраструктура для всех клиентов. Идентификация пользователя (user_id) действует в рамках тенанта; при необходимости — составной ключ (tenant_id, user_id).

---

## Вариант 1. REST без стриминга

**Суть подхода:** Один POST-запрос с сообщением пользователя; сервер вызывает LLM, дожидается полного ответа, возвращает его одним JSON-ответом. Диалоги в PostgreSQL по tenant_id и user_id; изоляция тенантов на уровне схемы/таблиц или фильтра по tenant_id.

**Изменения:** FastAPI, один POST-эндпоинт (tenant_id в заголовке/теле/поддомене — единая политика для SaaS), синхронный или асинхронный вызов LLM, чтение промпта из файла (при необходимости — на уровне тенанта), конфиг из .env. Клиент (iframe) — форма + один запрос, отображение ответа после загрузки. БД: таблицы с tenant_id; все выборки и вставки с фильтром по тенанту.

**Риски:** Длинные ответы — пользователь долго ждёт без обратной связи; таймауты при больших контекстах.

**Плюсы:** Минимальная сложность стека, простая отладка, нет состояния соединения.
**Минусы:** Плохой UX при длинных ответах, субъективно «зависание» интерфейса.

---

## Вариант 2. REST + SSE (выбран)

**Суть подхода:** POST-запрос с сообщением; сервер вызывает LLM с поддержкой стриминга и потоково отдаёт токены по SSE. После завершения стрима сохраняет сообщение пользователя и полный ответ ассистента в PostgreSQL по tenant_id и user_id. SaaS: изоляция по tenant_id во всех операциях; один пул соединений и инстансы приложения обслуживают множество тенантов.

**Изменения:** FastAPI, POST для приёма сообщения (tenant_id + user_id в запросе), ответ с Content-Type для SSE и потоковая передача токенов от LLM. Клиент в iframe: форма + приём SSE, пошаговое отображение ответа. Конфиг из .env, промпт из файла (или на уровне тенанта). БД и кэш — везде учёт tenant_id для изоляции данных.

**Риски:** Умеренные: нужно корректно обрабатывать разрыв соединения и ошибки LLM (сохранение/несохранение частичного ответа — решение зафиксировать).

**Плюсы:** Приемлемый UX без введения очередей и воркеров; один процесс приложения; знакомый стек (REST + SSE).
**Минусы:** Стриминг усложняет обработку ошибок и граничных случаев по сравнению с Вариантом 1.

---

## Вариант 3. WebSocket

**Суть подхода:** Постоянное соединение WebSocket; клиент отправляет сообщения по сокету, сервер стримит ответ LLM по тому же сокету. Диалоги в PostgreSQL по tenant_id и user_id. SaaS: при установке соединения передаётся tenant_id (и при необходимости user_id); маршрутизация и изоляция по тенанту на уровне сессии.

**Изменения:** FastAPI (или другой фреймворк) с поддержкой WebSocket, управление жизненным циклом соединения, протокол сообщений (JSON-фреймы). Клиент — WebSocket-клиент вместо REST+SSE.

**Риски:** Сложнее масштабирование (привязка к инстансу), больше кода для переподключений и восстановления сессии.

**Плюсы:** Двунаправленный канал, единый транспорт для запроса и стрима.
**Минусы:** Избыточен для задачи «один запрос — один стрим ответа»; усложняет стек и эксплуатацию без явной выгоды для постановки.

---

## Вариант 4. Очередь задач (фоновая обработка)

**Суть подхода:** POST кладёт задачу в очередь (Redis/RQ, Celery и т.п.); воркер забирает задачу, вызывает LLM, пишет результат в БД или кэш; клиент опрашивает статус или подписывается на уведомление. Стриминг при необходимости — через отдельный канал (SSE/WebSocket) по id задачи. SaaS: каждая задача и результат привязаны к tenant_id; очереди могут быть общими с меткой тенанта или раздельными на инстанс — явное решение в проектировании.

**Изменения:** Брокер сообщений, воркеры, схема «запрос → задача → результат», клиент — поллинг или подписка. Конфиг из .env, промпт из файла, диалоги в PostgreSQL.

**Риски:** Существенно более сложная инфраструктура, отложенная доставка ответа, согласованность «задача — диалог».

**Плюсы:** Горизонтальное масштабирование воркеров, устойчивость к пикам нагрузки.
**Минусы:** Избыточная сложность для текущей постановки; введение брокера и воркеров не требуется по критериям задачи.

---

## Сравнение по приоритетам

| Критерий              | Вариант 1 | Вариант 2 (выбран) | Вариант 3 | Вариант 4 |
|-----------------------|-----------|---------------------|-----------|-----------|
| Сопровождаемость      | Высокая   | Высокая             | Средняя   | Низкая    |
| Масштаб изменений     | Минимальный | Умеренный         | Большой   | Большой   |
| Риск регрессий        | Низкий    | Умеренный           | Выше      | Выше      |
| Долгосрочная стоимость| Низкая   | Умеренная           | Выше      | Высокая   |
| UX (длинные ответы)   | Слабый    | Хороший             | Хороший   | Зависит от реализации |
| Готовность к SaaS     | Да (tenant_id в БД и API) | Да (tenant_id в БД и API) | Да (tenant_id в сессии) | Да (tenant_id в задачах и БД) |

**Итог:** Выбран Вариант 2 (REST + SSE) как баланс между простотой стека, приемлемым UX, поддержкой мультитенантной SaaS-модели и минимально необходимыми изменениями для задачи CIP.
